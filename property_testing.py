from hypothesis import given, strategies as st
from hypothesis import settings, HealthCheck
from PathPlanning.AStar.a_star import AStarPlanner
import math

@given(
  st.tuples(
    st.floats(min_value=0.0, max_value=10.0),
    st.floats(min_value=0.0, max_value=10.0),
    st.floats(min_value=0.0, max_value=10.0),
    st.floats(min_value=0.0, max_value=10.0),
  ).filter(lambda t: (t[0], t[1]) != (t[2], t[3]))
)
@settings(suppress_health_check=[HealthCheck.filter_too_much], max_examples=100)
def test_path_starts_and_ends_correctly(data):
  """
  Property-based test to verify that the path returned by A* starts and ends at the correct grid positions.
  The test uses randomly generated start and goal positions, ensuring they are different.
  An artificial obstacle is placed far from the grid to avoid affecting the result.
  """
  sx, sy, gx, gy = data

  ox = [100.0]
  oy = [100.0]

  planner = AStarPlanner(ox, oy, resolution=1.0, rr=0.5)
  rx, ry = planner.planning(sx, sy, gx, gy)

  if len(rx) < 2: return

  start = (sx, sy)
  goal = (gx, gy)
  actual_start = (rx[-1], ry[-1])
  actual_goal = (rx[0], ry[0])

  tol = planner.resolution

  assert math.isclose(actual_start[0], start[0], abs_tol=tol)
  assert math.isclose(actual_start[1], start[1], abs_tol=tol)
  assert math.isclose(actual_goal[0], goal[0], abs_tol=tol)
  assert math.isclose(actual_goal[1], goal[1], abs_tol=tol)


def valid_obstacle(x, y):
    return math.hypot(x - 0.0, y - 0.0) > 1.0 and math.hypot(x - 19.0, y - 19.0) > 1.0


@given(
  st.lists(
    st.tuples(
      st.floats(min_value=0, max_value=20),
      st.floats(min_value=0, max_value=20)
    ).filter(lambda p: valid_obstacle(p[0], p[1])),
    min_size=10, max_size=30
  )
)
@settings(suppress_health_check=[HealthCheck.filter_too_much], max_examples=100)
def test_path_avoids_obstacles(obstacles):
  """
  Property-based test to ensure that the path generated by A* does not intersect any obstacles.
  Random obstacles are generated while ensuring they are not too close to the start or goal.
  The test verifies that all waypoints of the path remain outside the robot's radius from any obstacle.
  """
  ox, oy = zip(*obstacles) if obstacles else ([], [])

  planner = AStarPlanner(ox, oy, resolution=1.0, rr=1.0)

  sx, sy = 0.0, 0.0
  gx, gy = 19.0, 19.0

  rx, ry = planner.planning(sx, sy, gx, gy)

  if len(rx) < 2: return

  for x, y in zip(rx, ry):
    for iox, ioy in zip(ox, oy):
      d = math.hypot(iox - x, ioy - y)
      assert d > planner.rr


def test_path_cost_is_monotonic():
  """
  Unit test to verify that the total cost of the A* path increases monotonically.
  It ensures that each step in the path adds a non-decreasing cost, reflecting cumulative distance.
  """
  ox = [100.0]
  oy = [100.0]

  planner = AStarPlanner(ox, oy, resolution=1.0, rr=0.5)

  sx, sy = 1.0, 1.0
  gx, gy = 8.0, 8.0
  rx, ry = planner.planning(sx, sy, gx, gy)

  if len(rx) < 2: return

  total, previous_cost = 0, 0
  for i in range(1, len(rx)):
    dx = rx[i] - rx[i - 1]
    dy = ry[i] - ry[i - 1]
    step_cost = math.hypot(dx, dy)

    total += step_cost
    assert total >= previous_cost
    previous_cost = total
